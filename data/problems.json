[
  {
    "id": "two-sum",
    "title": "Two Sum",
    "difficulty": "easy",
    "tags": ["arrays", "hash-table"],
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers that add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nExample 1:\n  Input: nums = [2,7,11,15], target = 9\n  Output: [0,1]\n  Explanation: nums[0] + nums[1] == 9\n\nExample 2:\n  Input: nums = [3,2,4], target = 6\n  Output: [1,2]\n\nConstraints:\n  - 2 <= nums.length <= 10^4\n  - -10^9 <= nums[i] <= 10^9\n  - Only one valid answer exists."
  },
  {
    "id": "reverse-string",
    "title": "Reverse String",
    "difficulty": "easy",
    "tags": ["strings", "two-pointers"],
    "description": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.\n\nExample 1:\n  Input: s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n  Output: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n\nExample 2:\n  Input: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n  Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n\nConstraints:\n  - 1 <= s.length <= 10^5\n  - s[i] is a printable ASCII character."
  },
  {
    "id": "valid-parentheses",
    "title": "Valid Parentheses",
    "difficulty": "easy",
    "tags": ["strings", "stack"],
    "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n  1. Open brackets must be closed by the same type of brackets.\n  2. Open brackets must be closed in the correct order.\n  3. Every close bracket has a corresponding open bracket of the same type.\n\nExample 1:\n  Input: s = \"()\"\n  Output: true\n\nExample 2:\n  Input: s = \"()[]{}\"\n  Output: true\n\nExample 3:\n  Input: s = \"(]\"\n  Output: false\n\nConstraints:\n  - 1 <= s.length <= 10^4\n  - s consists of parentheses only '()[]{}'."
  },
  {
    "id": "palindrome-number",
    "title": "Palindrome Number",
    "difficulty": "easy",
    "tags": ["math"],
    "description": "Given an integer x, return true if x is a palindrome, and false otherwise.\n\nAn integer is a palindrome when it reads the same forward and backward.\n\nExample 1:\n  Input: x = 121\n  Output: true\n  Explanation: 121 reads as 121 from left to right and from right to left.\n\nExample 2:\n  Input: x = -121\n  Output: false\n  Explanation: From left to right, it reads -121. From right to left it becomes 121-.\n\nExample 3:\n  Input: x = 10\n  Output: false\n  Explanation: Reads 01 from right to left.\n\nConstraints:\n  - -2^31 <= x <= 2^31 - 1\n\nFollow up: Could you solve it without converting the integer to a string?"
  },
  {
    "id": "merge-sorted-arrays",
    "title": "Merge Two Sorted Arrays",
    "difficulty": "easy",
    "tags": ["arrays", "two-pointers", "sorting"],
    "description": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\n\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\n\nThe final sorted array should be stored inside nums1. To accommodate this, nums1 has a length of m + n, where the last n elements are set to 0 and should be ignored.\n\nExample 1:\n  Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\n  Output: [1,2,2,3,5,6]\n\nExample 2:\n  Input: nums1 = [1], m = 1, nums2 = [], n = 0\n  Output: [1]\n\nConstraints:\n  - nums1.length == m + n\n  - nums2.length == n\n  - 0 <= m, n <= 200"
  },
  {
    "id": "climbing-stairs",
    "title": "Climbing Stairs",
    "difficulty": "easy",
    "tags": ["dynamic-programming", "math"],
    "description": "You are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\nExample 1:\n  Input: n = 2\n  Output: 2\n  Explanation: There are two ways to climb to the top.\n    1. 1 step + 1 step\n    2. 2 steps\n\nExample 2:\n  Input: n = 3\n  Output: 3\n  Explanation: There are three ways to climb to the top.\n    1. 1 step + 1 step + 1 step\n    2. 1 step + 2 steps\n    3. 2 steps + 1 step\n\nConstraints:\n  - 1 <= n <= 45"
  },
  {
    "id": "best-time-to-buy-sell-stock",
    "title": "Best Time to Buy and Sell Stock",
    "difficulty": "medium",
    "tags": ["arrays", "dynamic-programming", "greedy"],
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n\nExample 1:\n  Input: prices = [7,1,5,3,6,4]\n  Output: 5\n  Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\n\nExample 2:\n  Input: prices = [7,6,4,3,1]\n  Output: 0\n  Explanation: No profitable transaction is possible.\n\nConstraints:\n  - 1 <= prices.length <= 10^5\n  - 0 <= prices[i] <= 10^4"
  },
  {
    "id": "container-with-most-water",
    "title": "Container With Most Water",
    "difficulty": "medium",
    "tags": ["arrays", "two-pointers", "greedy"],
    "description": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn the maximum amount of water a container can store.\n\nExample 1:\n  Input: height = [1,8,6,2,5,4,8,3,7]\n  Output: 49\n  Explanation: Lines at index 1 and 8 form the container with area = min(8,7) * (8-1) = 49.\n\nExample 2:\n  Input: height = [1,1]\n  Output: 1\n\nConstraints:\n  - n == height.length\n  - 2 <= n <= 10^5\n  - 0 <= height[i] <= 10^4"
  },
  {
    "id": "three-sum",
    "title": "3Sum",
    "difficulty": "medium",
    "tags": ["arrays", "two-pointers", "sorting"],
    "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nNotice that the solution set must not contain duplicate triplets.\n\nExample 1:\n  Input: nums = [-1,0,1,2,-1,-4]\n  Output: [[-1,-1,2],[-1,0,1]]\n\nExample 2:\n  Input: nums = [0,1,1]\n  Output: []\n\nExample 3:\n  Input: nums = [0,0,0]\n  Output: [[0,0,0]]\n\nConstraints:\n  - 3 <= nums.length <= 3000\n  - -10^5 <= nums[i] <= 10^5"
  },
  {
    "id": "group-anagrams",
    "title": "Group Anagrams",
    "difficulty": "medium",
    "tags": ["strings", "hash-table", "sorting"],
    "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n\nAn anagram is a word or phrase formed by rearranging the letters of a different word or phrase, using all the original letters exactly once.\n\nExample 1:\n  Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\n  Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\nExample 2:\n  Input: strs = [\"\"]\n  Output: [[\"\"]]\n\nExample 3:\n  Input: strs = [\"a\"]\n  Output: [[\"a\"]]\n\nConstraints:\n  - 1 <= strs.length <= 10^4\n  - 0 <= strs[i].length <= 100\n  - strs[i] consists of lowercase English letters."
  },
  {
    "id": "binary-tree-level-order",
    "title": "Binary Tree Level Order Traversal",
    "difficulty": "medium",
    "tags": ["trees", "bfs", "queue"],
    "description": "Given the root of a binary tree, return the level order traversal of its nodes' values (i.e., from left to right, level by level).\n\nExample 1:\n  Input: root = [3,9,20,null,null,15,7]\n  Output: [[3],[9,20],[15,7]]\n\nExample 2:\n  Input: root = [1]\n  Output: [[1]]\n\nExample 3:\n  Input: root = []\n  Output: []\n\nConstraints:\n  - The number of nodes in the tree is in the range [0, 2000].\n  - -1000 <= Node.val <= 1000"
  },
  {
    "id": "longest-substring-no-repeat",
    "title": "Longest Substring Without Repeating Characters",
    "difficulty": "medium",
    "tags": ["strings", "sliding-window", "hash-table"],
    "description": "Given a string s, find the length of the longest substring without repeating characters.\n\nExample 1:\n  Input: s = \"abcabcbb\"\n  Output: 3\n  Explanation: The answer is \"abc\", with the length of 3.\n\nExample 2:\n  Input: s = \"bbbbb\"\n  Output: 1\n  Explanation: The answer is \"b\", with the length of 1.\n\nExample 3:\n  Input: s = \"pwwkew\"\n  Output: 3\n  Explanation: The answer is \"wke\", with the length of 3.\n\nConstraints:\n  - 0 <= s.length <= 5 * 10^4\n  - s consists of English letters, digits, symbols and spaces."
  },
  {
    "id": "coin-change",
    "title": "Coin Change",
    "difficulty": "medium",
    "tags": ["dynamic-programming", "arrays"],
    "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nExample 1:\n  Input: coins = [1,5,10,25], amount = 30\n  Output: 2\n  Explanation: 5 + 25 = 30\n\nExample 2:\n  Input: coins = [2], amount = 3\n  Output: -1\n\nExample 3:\n  Input: coins = [1], amount = 0\n  Output: 0\n\nConstraints:\n  - 1 <= coins.length <= 12\n  - 1 <= coins[i] <= 2^31 - 1\n  - 0 <= amount <= 10^4"
  },
  {
    "id": "number-of-islands",
    "title": "Number of Islands",
    "difficulty": "medium",
    "tags": ["graphs", "dfs", "bfs", "matrix"],
    "description": "Given an m x n 2D binary grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water.\n\nExample 1:\n  Input: grid = [\n    [\"1\",\"1\",\"1\",\"1\",\"0\"],\n    [\"1\",\"1\",\"0\",\"1\",\"0\"],\n    [\"1\",\"1\",\"0\",\"0\",\"0\"],\n    [\"0\",\"0\",\"0\",\"0\",\"0\"]\n  ]\n  Output: 1\n\nExample 2:\n  Input: grid = [\n    [\"1\",\"1\",\"0\",\"0\",\"0\"],\n    [\"1\",\"1\",\"0\",\"0\",\"0\"],\n    [\"0\",\"0\",\"1\",\"0\",\"0\"],\n    [\"0\",\"0\",\"0\",\"1\",\"1\"]\n  ]\n  Output: 3\n\nConstraints:\n  - m == grid.length\n  - n == grid[i].length\n  - 1 <= m, n <= 300\n  - grid[i][j] is '0' or '1'."
  },
  {
    "id": "merge-intervals",
    "title": "Merge Intervals",
    "difficulty": "medium",
    "tags": ["arrays", "sorting"],
    "description": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n\nExample 1:\n  Input: intervals = [[1,3],[2,6],[8,10],[15,18]]\n  Output: [[1,6],[8,10],[15,18]]\n  Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\nExample 2:\n  Input: intervals = [[1,4],[4,5]]\n  Output: [[1,5]]\n  Explanation: Intervals [1,4] and [4,5] are considered overlapping.\n\nConstraints:\n  - 1 <= intervals.length <= 10^4\n  - intervals[i].length == 2\n  - 0 <= starti <= endi <= 10^4"
  }
]
